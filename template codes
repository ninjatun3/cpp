# класс матрица
class MyMatrix:
    # базовый контсруктор матрицы, создающий матрицу из двух поступающих списков
    def __init__(self, matrix):
        self.matrix = matrix

    # переопределяем метод str для вывода матрицы построчно в правильном порядке
    def __str__(self):
        for i in range(len(self.matrix)):
            for j in range(len(self.matrix[i])):
                print(self.matrix[i][j], end="\t") 
            print(end="\n")
        return self.matrix
        
    # метод сложения матриц
    def add(self, matrix1, matrix2):
        self.matrix1 = matrix1
        self.matrix2 = matrix2
        self.sum = self.matrix1
        # проверка одинаковой размерности складываемых матриц
        if(len(self.matrix1) == len(self.matrix2)):
            for i in range(len(self.matrix1)):
                for j in range (len(self.matrix1[i])):
                    self.sum[i][j] = self.matrix1[i][j] + self.matrix2[i][j]
        # устанавливаем выдачу ошибки из-за размерности матриц
        else:
            raise MatrixError(matrix1, matrix2)
        return self.sum

    def make_matrix(self, list1, list2):
        self.list1 = list1
        self.list2 = list2
        self.matrix = list([list1, list2])
        return self.matrix

# класс для обработки ошибок
class MatrixError(BaseException):
    def __init__(self, matrix1, matrix2):
        self.arg1 = matrix1
        self.arg2 = matrix2
        
# более простая реализация вывода матрицы
enter_matrix2 = MyMatrix(enter_matrix)
for i in enter_matrix2.matrix:
    print(*i)

# проверка на ошибку
try:
    print("matrix add:")
    for i in matrix_new.add(matrix_new.make_matrix(list11,list22),enter_matrix2):
        print(*i, sep="\t", end="\n")
# если условие не выполняется, то срабатывает else с созданием обьекта класса ошибки и отображением матриц с ошибкой     
except MatrixError as me:
    print("Error in matrixes:", me.arg1, me.arg2)
